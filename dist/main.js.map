{"version":3,"file":"main.js","sources":["../node_modules/@vueuse/shared/index.mjs","../src/components/Base/BaseTextField.vue","../src/components/Base/BaseFieldWrapper.vue","../src/components/FieldAddressAutocomplete.vue","../src/components/Base/BaseSelect.vue","../src/components/FieldAddressSelect.vue","../src/components/FieldCountry.vue","../src/components/FieldPostalCode.vue","../src/components/FieldHouseNumber.vue","../src/components/FieldHouseNumberSuffix.vue","../src/components/FieldStreet.vue","../src/components/FieldCity.vue","../src/components/ButtonOverride.vue","../node_modules/@hey-api/client-fetch/dist/index.js","../src/api-client/sdk.gen.ts","../src/composables/useConfig.ts","../src/composables/useApiClient.ts","../src/composables/useAdressApi.ts","../src/composables/useAddressData.ts","../src/components/TheAddressWidget.vue","../src/app.ts"],"sourcesContent":["import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, hasInjectionContext, inject, provide, isRef, unref, toValue as toValue$1, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? undefined : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = undefined;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? undefined : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get(v);\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? undefined : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const clear = () => {\n    fns.clear();\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (...args) => {\n    return Promise.all(Array.from(fns).map((fn) => fn(...args)));\n  };\n  return {\n    on,\n    off,\n    trigger,\n    clear\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? undefined : _a.proxy;\n  if (instance == null && !hasInjectionContext())\n    throw new Error(\"injectLocal must be called in setup\");\n  if (instance && localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? undefined : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? undefined : options.injectionKey) || Symbol(composable.name || \"InjectionState\");\n  const defaultValue = options == null ? undefined : options.defaultValue;\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key, defaultValue);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = undefined;\n      scope = undefined;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!scope) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? undefined : options.computedGetter) === false ? unref : toValue$1;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue$1(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a, _b;\n  return isClient && ((_a = window == null ? undefined : window.navigator) == null ? undefined : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? undefined : window.navigator) == null ? undefined : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? undefined : window.navigator.userAgent));\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue$1(ms);\n    const maxDuration = toValue$1(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== undefined && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(...args) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  let ms;\n  let trailing;\n  let leading;\n  let rejectOnCancel;\n  if (!isRef(args[0]) && typeof args[0] === \"object\")\n    ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);\n  else\n    [ms, trailing = true, leading = true, rejectOnCancel = false] = args;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = undefined;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue$1(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = undefined;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?\\d+\\.?\\d*/)) == null ? undefined : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction pxValue(px) {\n  return px.endsWith(\"rem\") ? Number.parseFloat(px) * 16 : Number.parseFloat(px);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== undefined)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== undefined) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction getLifeCycleTarget(target) {\n  return target || getCurrentInstance();\n}\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue$1(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue$1(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue$1(defaultValue);\n      trigger();\n    }, toValue$1(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? undefined : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? undefined : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    const [target, key, value] = args;\n    target[key] = value;\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  targets = toArray(targets);\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue$1(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nconst toValue = toValue$1;\nconst resolveUnref = toValue$1;\n\nfunction tryOnBeforeMount(fn, sync = true, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeMount(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onBeforeUnmount(fn, target);\n}\n\nfunction tryOnMounted(fn, sync = true, target) {\n  const instance = getLifeCycleTarget();\n  if (instance)\n    onMounted(fn, target);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn, target) {\n  const instance = getLifeCycleTarget(target);\n  if (instance)\n    onUnmounted(fn, target);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? undefined : stop());\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => stop == null ? undefined : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            if (stop)\n              stop();\n            else\n              nextTick(() => stop == null ? undefined : stop());\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue$1(r)).finally(() => {\n          stop == null ? undefined : stop();\n          return toValue$1(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(undefined, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue$1(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue$1(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a, _b;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  const {\n    symmetric = false\n  } = (_b = args[3]) != null ? _b : {};\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  const diff1 = computed(() => toValue$1(list).filter((x) => toValue$1(values).findIndex((y) => compareFn(x, y)) === -1));\n  if (symmetric) {\n    const diff2 = computed(() => toValue$1(values).filter((x) => toValue$1(list).findIndex((y) => compareFn(x, y)) === -1));\n    return computed(() => symmetric ? [...toValue$1(diff1), ...toValue$1(diff2)] : toValue$1(diff1));\n  } else {\n    return diff1;\n  }\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue$1(list).every((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue$1(\n    toValue$1(list).find((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue$1(list).findIndex((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return undefined;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue$1(\n    !Array.prototype.findLast ? findLast(toValue$1(list), (element, index, array) => fn(toValue$1(element), index, array)) : toValue$1(list).findLast((element, index, array) => fn(toValue$1(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue$1(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue$1(value2);\n  return computed(() => toValue$1(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue$1(element),\n    toValue$1(value),\n    index,\n    toValue$1(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).join(toValue$1(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue$1(list).map((i) => toValue$1(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue$1(sum), toValue$1(value), index);\n  return computed(() => {\n    const resolved = toValue$1(list);\n    return args.length ? resolved.reduce(reduceCallback, typeof args[0] === \"function\" ? toValue$1(args[0]()) : toValue$1(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue$1(list).some((element, index, array) => fn(toValue$1(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue$1(list).map((element) => toValue$1(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.max(Math.min(max, count.value + delta), min);\n  const dec = (delta = 1) => count.value = Math.min(Math.max(min, count.value - delta), max);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[T\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/i;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)\\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(toValue$1(options.locales), { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(toValue$1(options.locales), { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? undefined : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === undefined)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue$1(date)), toValue$1(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue$1(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    if (isActive.value)\n      timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue$1(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue$1(value);\n    if (typeof method === \"function\")\n      resolved = method(resolved);\n    else if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue$1(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue$1(truthyValue);\n      _value.value = _value.value === truthy ? toValue$1(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? undefined : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue$1(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue$1(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = undefined,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = undefined;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue$1(item));\n  return toValue$1(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => undefined) : undefined;\n}\n\nfunction whenever(source, cb, options) {\n  const stop = watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v) {\n        if (options == null ? undefined : options.once)\n          nextTick(() => stop());\n        cb(v, ov, onInvalidate);\n      }\n    },\n    {\n      ...options,\n      once: false\n    }\n  );\n  return stop;\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, computedEager as eagerComputed, extendRef, formatDate, get, getLifeCycleTarget, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, pxValue, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toArray, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","<template>\n  <input\n    v-model=\"model\"\n    type=\"text\" />\n</template>\n\n<script lang=\"ts\" setup>\nconst model = defineModel<string>();\n</script>\n\n<style scoped>\ninput[disabled] {\n  @apply text-gray-500;\n  @apply bg-gray-200;\n}\ninput[readonly] {\n  @apply bg-gray-100;\n}\n</style>\n","<template>\n  <div>\n    <slot></slot>\n  </div>\n</template>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"searchQuery\">Street, Housenumber, City</label>\n    <BaseTextField\n      id=\"searchQuery\"\n      v-model=\"searchQuery\"\n      name=\"searchQuery\"\n      required\n      v-bind=\"$attrs\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseTextField from '@/components/Base/BaseTextField.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\n\ndefineOptions({\n  inheritAttrs: false,\n});\nconst searchQuery = defineModel<string>();\n</script>\n","<template>\n  <select v-model=\"model\">\n    <option\n      v-for=\"option in computedOptions\"\n      :key=\"option.value\"\n      :value=\"option.value\">\n      {{ option.label }}\n    </option>\n  </select>\n</template>\n\n<script lang=\"ts\" setup>\nimport {computed} from 'vue';\n\ntype SelectOptions = {\n  options: {value: string; label: string}[];\n  addEmptyOption?: boolean;\n};\n\nconst props = withDefaults(defineProps<SelectOptions>(), {\n  addEmptyOption: true,\n});\nconst model = defineModel<string | null | undefined>({default: ''});\n\nconst computedOptions = computed(() => {\n  if (props.addEmptyOption) {\n    return [{value: '', label: 'Select an option'}, ...props.options];\n  }\n  return props.options;\n});\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"addressSelect\">Select the right address</label>\n    <BaseSelect\n      name=\"addressSelect\"\n      :options=\"addressOptions\"\n      @input=\"onSelect\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Address} from '@/api-client';\nimport {defineEmits, computed} from 'vue';\nimport BaseSelect from './Base/BaseSelect.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\ndefineOptions({\n  inheritAttrs: false,\n});\nconst props = defineProps<{\n  addresses: Address[];\n}>();\n\nconst emit = defineEmits<{\n  (e: 'address-select', selectedAddress: Address): void;\n}>();\n\nconst addressOptions = computed(() => {\n  return props.addresses.map((address, index) => ({\n    value: index.toString(),\n    label: `${address.street} ${address.houseNumber}${address.houseNumberSuffix || ''}, ${address.city}`,\n  }));\n});\n\nconst onSelect = (e: InputEvent) => {\n  const target = e.target as HTMLSelectElement;\n  if (!target.value) return;\n\n  // Get address by index and emit it\n  const selectedIndex = parseInt(target.value);\n  const selectedAddress = props.addresses[selectedIndex];\n  emit('address-select', selectedAddress);\n};\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"country\">Country</label>\n    <BaseSelect\n      v-model=\"country\"\n      name=\"country\"\n      :options=\"countryOptions\"\n      required\n      v-bind=\"$attrs\"></BaseSelect>\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue';\nimport BaseSelect from '@/components/Base/BaseSelect.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\nimport type {Alpha2CountryCode} from '@/api-client';\ndefineOptions({\n  inheritAttrs: false,\n});\nconst country = defineModel<Alpha2CountryCode | null>();\n\n// Defines a prop that lists all allowed countries, if none are given, all countries are allowed\ntype countryObject = {\n  code: Alpha2CountryCode;\n  label: string;\n};\n// TODO: Use myparcel validator to check if the CC is correct\nconst props = defineProps<{\n  allowedCountries?: countryObject[];\n}>();\n// All the options which are possible. Used if no allowedCountries are given\nconst availableCountries: countryObject[] = [\n  {code: 'NL', label: 'Netherlands'},\n  {code: 'BE', label: 'Belgium'},\n];\n\nconst countryOptions = computed(() =>\n  props.allowedCountries?.length\n    ? props.allowedCountries.map((country) => ({\n        value: country.code,\n        label: country.label,\n      }))\n    : availableCountries.map((country) => ({\n        value: country.code,\n        label: country.label,\n      })),\n);\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"postalCode\">Postal code</label>\n    <BaseTextField\n      id=\"postalCode\"\n      v-model=\"postalCode\"\n      name=\"postalCode\"\n      length=\"4\"\n      required\n      inputmode=\"numeric\"\n      v-bind=\"$attrs\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseTextField from '@/components/Base/BaseTextField.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\ndefineOptions({\n  inheritAttrs: false,\n});\nconst postalCode = defineModel<string>();\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"houseNumber\">House number</label>\n    <BaseTextField\n      id=\"houseNumber\"\n      v-model=\"houseNumber\"\n      name=\"houseNumber\"\n      length=\"8\"\n      required\n      inputmode=\"numeric\"\n      v-bind=\"$attrs\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseTextField from '@/components/Base/BaseTextField.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\ndefineOptions({\n  inheritAttrs: false,\n});\nconst houseNumber = defineModel<string>();\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"houseNumberSuffix\"\n      >House number suffix <em>(optional)</em></label\n    >\n    <BaseTextField\n      id=\"houseNumberSuffix\"\n      v-model=\"houseNumberSuffix\"\n      name=\"houseNumberSuffix\"\n      length=\"5\"\n      v-bind=\"$attrs\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseTextField from '@/components/Base/BaseTextField.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\ndefineOptions({\n  inheritAttrs: false,\n});\nconst houseNumberSuffix = defineModel<string>();\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"street\">Street</label>\n    <BaseTextField\n      id=\"street\"\n      v-model=\"street\"\n      name=\"street\"\n      required\n      v-bind=\"$attrs\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseTextField from '@/components/Base/BaseTextField.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\n\ndefineOptions({\n  inheritAttrs: false,\n});\nconst street = defineModel<string>();\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <label for=\"city\">City</label>\n    <BaseTextField\n      id=\"city\"\n      v-model=\"city\"\n      name=\"city\"\n      required\n      v-bind=\"$attrs\" />\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseTextField from '@/components/Base/BaseTextField.vue';\nimport BaseFieldWrapper from '@/components/Base/BaseFieldWrapper.vue';\ndefineOptions({\n  inheritAttrs: false,\n});\nconst city = defineModel<string>();\n</script>\n","<template>\n  <BaseFieldWrapper>\n    <button @click.prevent=\"emitOverrideRequested\">Override address</button>\n  </BaseFieldWrapper>\n</template>\n\n<script setup lang=\"ts\">\nimport {defineEmits} from 'vue';\nimport BaseFieldWrapper from './Base/BaseFieldWrapper.vue';\n\nconst emit = defineEmits(['override-requested']);\n\nfunction emitOverrideRequested() {\n  emit('override-requested');\n}\n</script>\n\n<style scoped>\nbutton {\n  @apply text-blue-500 bg-slate-100 px-3 py-2;\n}\n</style>\n","var k=/\\{[^{}]+\\}/g,S=({allowReserved:n,name:r,value:e})=>{if(e==null)return \"\";if(typeof e==\"object\")throw new Error(\"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\");return `${r}=${n?e:encodeURIComponent(e)}`},U=n=>{switch(n){case\"label\":return \".\";case\"matrix\":return \";\";case\"simple\":return \",\";default:return \"&\"}},$=n=>{switch(n){case\"form\":return \",\";case\"pipeDelimited\":return \"|\";case\"spaceDelimited\":return \"%20\";default:return \",\"}},D=n=>{switch(n){case\"label\":return \".\";case\"matrix\":return \";\";case\"simple\":return \",\";default:return \"&\"}},z=({allowReserved:n,explode:r,name:e,style:s,value:a})=>{if(!r){let t=(n?a:a.map(c=>encodeURIComponent(c))).join($(s));switch(s){case\"label\":return `.${t}`;case\"matrix\":return `;${e}=${t}`;case\"simple\":return t;default:return `${e}=${t}`}}let o=U(s),i=a.map(t=>s===\"label\"||s===\"simple\"?n?t:encodeURIComponent(t):S({allowReserved:n,name:e,value:t})).join(o);return s===\"label\"||s===\"matrix\"?o+i:i},C=({allowReserved:n,explode:r,name:e,style:s,value:a})=>{if(a instanceof Date)return `${e}=${a.toISOString()}`;if(s!==\"deepObject\"&&!r){let t=[];Object.entries(a).forEach(([u,p])=>{t=[...t,u,n?p:encodeURIComponent(p)];});let c=t.join(\",\");switch(s){case\"form\":return `${e}=${c}`;case\"label\":return `.${c}`;case\"matrix\":return `;${e}=${c}`;default:return c}}let o=D(s),i=Object.entries(a).map(([t,c])=>S({allowReserved:n,name:s===\"deepObject\"?`${e}[${t}]`:t,value:c})).join(o);return s===\"label\"||s===\"matrix\"?o+i:i},_=({path:n,url:r})=>{let e=r,s=r.match(k);if(s)for(let a of s){let o=!1,i=a.substring(1,a.length-1),t=\"simple\";i.endsWith(\"*\")&&(o=!0,i=i.substring(0,i.length-1)),i.startsWith(\".\")?(i=i.substring(1),t=\"label\"):i.startsWith(\";\")&&(i=i.substring(1),t=\"matrix\");let c=n[i];if(c==null)continue;if(Array.isArray(c)){e=e.replace(a,z({explode:o,name:i,style:t,value:c}));continue}if(typeof c==\"object\"){e=e.replace(a,C({explode:o,name:i,style:t,value:c}));continue}if(t===\"matrix\"){e=e.replace(a,`;${S({name:i,value:c})}`);continue}let u=encodeURIComponent(t===\"label\"?`.${c}`:c);e=e.replace(a,u);}return e},w=({allowReserved:n,array:r,object:e}={})=>a=>{let o=[];if(a&&typeof a==\"object\")for(let i in a){let t=a[i];if(t!=null){if(Array.isArray(t)){o=[...o,z({allowReserved:n,explode:!0,name:i,style:\"form\",value:t,...r})];continue}if(typeof t==\"object\"){o=[...o,C({allowReserved:n,explode:!0,name:i,style:\"deepObject\",value:t,...e})];continue}o=[...o,S({allowReserved:n,name:i,value:t})];}}return o.join(\"&\")},A=n=>{if(!n)return;let r=n.split(\";\")[0]?.trim();if(r){if(r.startsWith(\"application/json\")||r.endsWith(\"+json\"))return \"json\";if(r===\"multipart/form-data\")return \"formData\";if([\"application/\",\"audio/\",\"image/\",\"video/\"].some(e=>r.startsWith(e)))return \"blob\";if(r.startsWith(\"text/\"))return \"text\"}},H=async(n,r)=>{if(n.fn===\"accessToken\"){let e=typeof r.accessToken==\"function\"?await r.accessToken():r.accessToken;return e?`Bearer ${e}`:void 0}if(n.fn===\"apiKey\")return typeof r.apiKey==\"function\"?await r.apiKey():r.apiKey},P=async({security:n,...r})=>{for(let e of n){let s=await H(e,r);if(s){e.in===\"header\"?r.headers.set(e.name,s):e.in===\"query\"&&(r.query||(r.query={}),r.query[e.name]=s);return}}},b=n=>W({baseUrl:n.baseUrl??\"\",path:n.path,query:n.query,querySerializer:typeof n.querySerializer==\"function\"?n.querySerializer:w(n.querySerializer),url:n.url}),W=({baseUrl:n,path:r,query:e,querySerializer:s,url:a})=>{let o=a.startsWith(\"/\")?a:`/${a}`,i=n+o;r&&(i=_({path:r,url:i}));let t=e?s(e):\"\";return t.startsWith(\"?\")&&(t=t.substring(1)),t&&(i+=`?${t}`),i},R=(n,r)=>{let e={...n,...r};return e.baseUrl?.endsWith(\"/\")&&(e.baseUrl=e.baseUrl.substring(0,e.baseUrl.length-1)),e.headers=O(n.headers,r.headers),e},O=(...n)=>{let r=new Headers;for(let e of n){if(!e||typeof e!=\"object\")continue;let s=e instanceof Headers?e.entries():Object.entries(e);for(let[a,o]of s)if(o===null)r.delete(a);else if(Array.isArray(o))for(let i of o)r.append(a,i);else o!==void 0&&r.set(a,typeof o==\"object\"?JSON.stringify(o):o);}return r},y=class{_fns;constructor(){this._fns=[];}clear(){this._fns=[];}exists(r){return this._fns.indexOf(r)!==-1}eject(r){let e=this._fns.indexOf(r);e!==-1&&(this._fns=[...this._fns.slice(0,e),...this._fns.slice(e+1)]);}use(r){this._fns=[...this._fns,r];}},T=()=>({error:new y,request:new y,response:new y}),x=(n,r,e)=>{typeof e==\"string\"||e instanceof Blob?n.append(r,e):n.append(r,JSON.stringify(e));},B={bodySerializer:n=>{let r=new FormData;return Object.entries(n).forEach(([e,s])=>{s!=null&&(Array.isArray(s)?s.forEach(a=>x(r,e,a)):x(r,e,s));}),r}},E={bodySerializer:n=>JSON.stringify(n)},j=(n,r,e)=>{typeof e==\"string\"?n.append(r,e):n.append(r,JSON.stringify(e));},N={bodySerializer:n=>{let r=new URLSearchParams;return Object.entries(n).forEach(([e,s])=>{s!=null&&(Array.isArray(s)?s.forEach(a=>j(r,e,a)):j(r,e,s));}),r}},Q=w({allowReserved:!1,array:{explode:!0,style:\"form\"},object:{explode:!0,style:\"deepObject\"}}),V={\"Content-Type\":\"application/json\"},q=(n={})=>({...E,baseUrl:\"\",headers:V,parseAs:\"auto\",querySerializer:Q,...n});var L=(n={})=>{let r=R(q(),n),e=()=>({...r}),s=i=>(r=R(r,i),e()),a=T(),o=async i=>{let t={...r,...i,fetch:i.fetch??r.fetch??globalThis.fetch,headers:O(r.headers,i.headers)};t.security&&await P({...t,security:t.security}),t.body&&t.bodySerializer&&(t.body=t.bodySerializer(t.body)),t.body||t.headers.delete(\"Content-Type\");let c=b(t),u={redirect:\"follow\",...t},p=new Request(c,u);for(let f of a.request._fns)p=await f(p,t);let I=t.fetch,l=await I(p);for(let f of a.response._fns)l=await f(l,p,t);let m={request:p,response:l};if(l.ok){if(l.status===204||l.headers.get(\"Content-Length\")===\"0\")return {data:{},...m};if(t.parseAs===\"stream\")return {data:l.body,...m};let f=(t.parseAs===\"auto\"?A(l.headers.get(\"Content-Type\")):t.parseAs)??\"json\",h=await l[f]();return f===\"json\"&&(t.responseValidator&&await t.responseValidator(h),t.responseTransformer&&(h=await t.responseTransformer(h))),{data:h,...m}}let g=await l.text();try{g=JSON.parse(g);}catch{}let d=g;for(let f of a.error._fns)d=await f(g,l,p,t);if(d=d||{},t.throwOnError)throw d;return {error:d,...m}};return {buildUrl:b,connect:i=>o({...i,method:\"CONNECT\"}),delete:i=>o({...i,method:\"DELETE\"}),get:i=>o({...i,method:\"GET\"}),getConfig:e,head:i=>o({...i,method:\"HEAD\"}),interceptors:a,options:i=>o({...i,method:\"OPTIONS\"}),patch:i=>o({...i,method:\"PATCH\"}),post:i=>o({...i,method:\"POST\"}),put:i=>o({...i,method:\"PUT\"}),request:o,setConfig:s,trace:i=>o({...i,method:\"TRACE\"})}};\n\nexport { L as createClient, q as createConfig, B as formDataBodySerializer, E as jsonBodySerializer, N as urlSearchParamsBodySerializer };\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map","// This file is auto-generated by @hey-api/openapi-ts\n\nimport { createClient, createConfig, type Options } from '@hey-api/client-fetch';\nimport type { GetAddressesData, GetAddressesError, GetAddressesResponse, GetValidateData, GetValidateError, GetValidateResponse } from './types.gen';\n\nexport const client = createClient(createConfig());\n\n/**\n * List addresses by query parameters.\n * List addresses.\n */\nexport const getAddresses = <ThrowOnError extends boolean = false>(options?: Options<GetAddressesData, ThrowOnError>) => {\n    return (options?.client ?? client).get<GetAddressesResponse, GetAddressesError, ThrowOnError>({\n        ...options,\n        security: [\n            {\n                fn: 'apiKey',\n                in: 'header',\n                name: 'Authorization'\n            }\n        ],\n        url: '/addresses'\n    });\n};\n\n/**\n * Validate an address by query parameters.\n * Validate an address.\n */\nexport const getValidate = <ThrowOnError extends boolean = false>(options: Options<GetValidateData, ThrowOnError>) => {\n    return (options?.client ?? client).get<GetValidateResponse, GetValidateError, ThrowOnError>({\n        ...options,\n        security: [\n            {\n                fn: 'apiKey',\n                in: 'header',\n                name: 'Authorization'\n            }\n        ],\n        url: '/validate'\n    });\n};","import {ref} from 'vue';\nexport const API_URL_DIRECT = 'https://address.api.myparcel.nl';\n\n/**\n * Provides configuration for the API client, both through the environment and window object.\n */\nexport function useConfig() {\n  const apiKey = ref<string | null>(import.meta.env.VITE_API_KEY);\n  const apiUrl = ref<string | null>(import.meta.env.API_URL || API_URL_DIRECT);\n\n  function setConfig(config: {apiKey?: string; apiUrl?: string}) {\n    // @TODO validate incoming config in runtime\n    if (config.apiKey) {\n      apiKey.value = config.apiKey;\n    }\n    if (config.apiUrl) {\n      apiUrl.value = config.apiUrl;\n    }\n  }\n\n  function setConfigFromWindow() {\n    if (typeof window !== 'undefined' && window.MyParcelAddressConfig) {\n      setConfig(window.MyParcelAddressConfig);\n    }\n  }\n\n  return {\n    apiKey,\n    apiUrl,\n    setConfig,\n    setConfigFromWindow,\n  };\n}\n","import {client} from '@/api-client/sdk.gen';\nimport {useConfig, API_URL_DIRECT} from '@/composables/useConfig.ts';\nimport {toValue} from 'vue';\n\n/**\n * Provides the API client instance with the correct configuration.\n */\nexport function useApiClient() {\n  const {setConfigFromWindow, apiKey, apiUrl} = useConfig();\n\n  setConfigFromWindow();\n\n  if (!apiUrl.value?.length) {\n    throw new Error('Cannot init API: API URL is not set');\n  }\n\n  if (!apiKey.value && apiUrl.value === API_URL_DIRECT) {\n    throw new Error('An API key must be set when using the default API URL');\n  }\n\n  client.setConfig({\n    baseUrl: apiUrl.value,\n  });\n\n  client.interceptors.request.use((request) => {\n    if (toValue(apiKey)?.length) {\n      // Send the API key as a base64 encoded bearer token as per https://developer.myparcel.nl/api-reference/05.authentication.html\n      request.headers.set(\n        'Authorization',\n        `bearer ${btoa(<string>toValue(apiKey))}`,\n      );\n    }\n    return request;\n  });\n\n  return {\n    client,\n  };\n}\n","import {\n  type Address,\n  type Alpha2CountryCode,\n  type GetAddressesData,\n  type ProblemDetailsBadRequest,\n  getAddresses,\n} from '@/api-client';\nimport {ref, toValue, type MaybeRefOrGetter, type Ref} from 'vue';\nimport {useApiClient} from './useApiClient';\n\nconst ABORT_REASON = new Error('Request cancelled because of new input');\n\n/**\n * Provides wrapper functions for the address API SDK.\n */\nexport function useAddressApi() {\n  const addressResults: Ref<Address[] | undefined> = ref();\n  const loading = ref(false);\n  const abortController: Ref<AbortController | undefined> = ref();\n\n  const isProblemDetailsBadRequest = (\n    error: unknown,\n  ): error is ProblemDetailsBadRequest => {\n    if (typeof error !== 'object' || error === null) {\n      return false;\n    }\n\n    const problemDetails = error as ProblemDetailsBadRequest;\n    return (\n      problemDetails.type === 'urn:problem:validation-error' &&\n      problemDetails.status === 400 &&\n      Array.isArray(problemDetails.errors)\n    );\n  };\n\n  /**\n   * Request address by postal code and house number.\n   *\n   * @param postalCode\n   * @param houseNumber\n   * @param countryCode\n   * @param houseNumberSuffix\n   */\n  const fetchAddressByPostalCode = async (\n    postalCode: MaybeRefOrGetter<string>,\n    houseNumber: MaybeRefOrGetter<string>,\n    countryCode: MaybeRefOrGetter<Alpha2CountryCode>,\n    houseNumberSuffix?: MaybeRefOrGetter<string>,\n  ) => {\n    // Postal code lookup is only supported for the Netherlands at this moment\n    if (toValue(countryCode) !== 'NL') {\n      throw new Error(\n        'Postal code lookup is only supported for the Netherlands', // @TODO translate\n      );\n    }\n\n    const params: GetAddressesData = {\n      query: {\n        postalCode: toValue(postalCode) || '',\n        houseNumber: toValue(houseNumber) || '',\n        houseNumberSuffix: toValue(houseNumberSuffix)?.length\n          ? toValue(houseNumberSuffix)\n          : undefined,\n        countryCode: toValue(countryCode),\n      },\n      url: '/addresses',\n    };\n\n    await getAddressesWithErrorHandling(params);\n  };\n\n  /**\n   * Look up an address by search query.\n   * @param searchQuery\n   * @param countryCode\n   */\n  const fetchAddressBySearchQuery = async (\n    searchQuery: MaybeRefOrGetter<string>,\n    countryCode?: MaybeRefOrGetter<Alpha2CountryCode>,\n  ) => {\n    const params: GetAddressesData = {\n      query: {\n        query: toValue(searchQuery),\n        countryCode: toValue(countryCode),\n      },\n      url: '/addresses',\n    };\n\n    await getAddressesWithErrorHandling(params);\n  };\n\n  /**\n   * Call the SDK `getAdresses` with standardized error handling and request aborts.\n   * @param params\n   */\n  const getAddressesWithErrorHandling = async (params: GetAddressesData) => {\n    const {client} = useApiClient();\n\n    // Abort any existing requests and create a new controller\n    abortController.value?.abort(ABORT_REASON);\n    abortController.value = new AbortController();\n\n    try {\n      loading.value = true;\n      const {error, response, data} = await getAddresses({\n        client,\n        ...params,\n        signal: abortController.value?.signal,\n      });\n      loading.value = false;\n\n      // Throw an error if the request didn't error but returned an error object.\n      if (error) {\n        throw error;\n      }\n\n      // If the request didn't error but the response was not ok, throw an error.\n      if (!response.ok) {\n        throw new Error('Failed to fetch address'); // @TODO translate\n      }\n\n      addressResults.value = data.results;\n    } catch (error) {\n      // Catch to reset loading state and rethrow\n      loading.value = false;\n\n      // Ignore the error if the request was aborted by us.\n      if (error === ABORT_REASON) {\n        console.debug(\n          'Request was aborted because it did not finish in time for new input.',\n        );\n        return;\n      }\n      throw error;\n    }\n  };\n\n  return {\n    addressResults,\n    loading,\n    isProblemDetailsBadRequest,\n    fetchAddressByPostalCode,\n    fetchAddressBySearchQuery,\n  };\n}\n","import type {Alpha2CountryCode} from '@/api-client';\nimport type {Address} from '@/api-client/types.gen';\nimport {computed, ref, toValue, watch, type Ref} from 'vue';\n\n/**\n * This composable contains all the logic for handling address data that is not specifically bound to UI implementation and/or user input events.\n */\n\nconst SEARCH_STREET_MIN_LENGTH = 3; // arbitrary minimum length for search queries\nconst POSTAL_CODE_MIN_LENGTH = 6; // eg. 1111AA - only relevant for NL postal codes at this point\nexport type AddressSelectEvent = {\n  (event: 'address-selected', address: Address | null): void;\n};\n\n/**\n * Provise reactive properties and methods for storing address data.\n * @param emit Provide an event emitter to emit events when the selected address changes. If empty, no events will be emitted.\n * @returns\n */\nexport function useAddressData(emit?: AddressSelectEvent) {\n  const countryCode: Ref<Alpha2CountryCode | undefined> = ref();\n  const postalCode: Ref<string | undefined> = ref();\n  const houseNumber: Ref<string | undefined> = ref();\n  const houseNumberSuffix: Ref<string | undefined> = ref();\n  const street: Ref<string | undefined> = ref();\n  const city: Ref<string | undefined> = ref();\n  const searchQuery: Ref<string | undefined> = ref();\n  const selectedAddress: Ref<Address | undefined> = ref(); // stores the full address for actual usage by consuming plugins/forms\n\n  /**\n   * Reset the form and stored address data.\n   */\n  const doReset = () => {\n    selectedAddress.value = undefined;\n    postalCode.value = undefined;\n    houseNumber.value = undefined;\n    houseNumberSuffix.value = undefined;\n    street.value = undefined;\n    city.value = undefined;\n    searchQuery.value = undefined;\n  };\n\n  /**\n   * Override both user input and the emitted address with incoming data.\n   */\n  const selectAddress = (address: Address) => {\n    selectedAddress.value = address;\n    postalCode.value = address.postalCode;\n    houseNumber.value = address.houseNumber;\n    houseNumberSuffix.value = address.houseNumberSuffix;\n    street.value = address.street;\n    city.value = address.city;\n  };\n\n  /**\n   * We use different kinds of lookups in NL (PostalCode-based) and rest-of world.\n   * This is a basic validator on whether we can do a lookup based on postal code and house number.\n   */\n  function hasRequiredPostalcodeLookupAttributes(data: {\n    countryCode: Ref<Alpha2CountryCode | undefined>;\n    postalCode: Ref<string | undefined>;\n    houseNumber: Ref<string | undefined>;\n  }): data is {\n    countryCode: Ref<'NL'>;\n    postalCode: Ref<string>;\n    houseNumber: Ref<string>;\n  } {\n    return (\n      toValue(data.countryCode) === 'NL' &&\n      (toValue(data.postalCode)?.length ?? 0) >= POSTAL_CODE_MIN_LENGTH &&\n      (toValue(data.houseNumber)?.length ?? 0) > 0\n    );\n  }\n\n  /**\n   * Only start searching when the query (probably) contains a street and house number by doing a simple regex check.\n   */\n  const isReadyForAutocompleteSearch = computed<boolean>(() => {\n    const regex = new RegExp(\n      `(?=.*[a-zA-Z]{${SEARCH_STREET_MIN_LENGTH},})(?=.*\\\\d)`,\n    );\n    return !!searchQuery.value && regex.test(searchQuery.value);\n  });\n\n  /**\n   * Computed property to check if we have all the required data to do a postal code lookup.\n   * This is slightly duplicated with the typeguard above -- using this computed is only possible in situations where the data should not need to be typed afterwards.\n   */\n  const isReadyForPostalCodeLookup = computed<boolean>(() => {\n    return hasRequiredPostalcodeLookupAttributes({\n      countryCode,\n      postalCode,\n      houseNumber,\n    });\n  });\n\n  // Emit an event whenever selectedAddress changes, as this will be relevant to watch for changes in consiming plugins/forms\n  if (emit) {\n    watch(selectedAddress, (address) => {\n      // TODO: Add exported consts with event names\n      emit('address-selected', address || null);\n      window.dispatchEvent(\n        new CustomEvent('address-selected', {detail: address}),\n      );\n    });\n  }\n\n  return {\n    countryCode,\n    postalCode,\n    houseNumber,\n    houseNumberSuffix,\n    street,\n    city,\n    searchQuery,\n    selectedAddress,\n    doReset,\n    selectAddress,\n    hasRequiredPostalcodeLookupAttributes,\n    isReadyForPostalCodeLookup,\n    isReadyForAutocompleteSearch,\n  };\n}\n","<template>\n  <pre>\n    Voorbeeld met toevoegingen:\n    Herestraat 77\n    9711 LC Groningen\n  </pre>\n  <div\n    class=\"p-4 flex flex-col space-y-4 max-w-80\"\n    :data-loading=\"loading\">\n    <FieldCountry\n      v-model=\"countryCode\"\n      @change.stop=\"handleCountryChange\"></FieldCountry>\n\n    <template v-if=\"countryCode?.length\">\n      <template v-if=\"countryCode === 'NL'\">\n        <span\n          v-if=\"notFound && !validationErrors?.length\"\n          class=\"text-red-500\">\n          No address found, are you sure the postal code and house number are\n          correct?\n        </span>\n        <span\n          v-if=\"validationErrors?.length\"\n          class=\"text-red-500\">\n          {{ validationErrors }}\n        </span>\n\n        <FieldPostalCode\n          v-model=\"postalCode\"\n          @input.stop=\"handlePostalCodeInput\"></FieldPostalCode>\n        <FieldHouseNumber\n          v-model=\"houseNumber\"\n          @input.stop=\"handlePostalCodeInput\"></FieldHouseNumber>\n        <FieldHouseNumberSuffix\n          v-model=\"houseNumberSuffix\"\n          @input.stop=\"handlePostalCodeInput\"></FieldHouseNumberSuffix>\n\n        <template\n          v-if=\"addressResults && addressResults?.length > 1 && !loading\">\n          <FieldAddressSelect\n            :addresses=\"addressResults\"\n            @address-select=\"selectAddress\"></FieldAddressSelect>\n        </template>\n\n        <template v-if=\"isReadyForPostalCodeLookup\">\n          <FieldStreet\n            v-model=\"street\"\n            :readonly=\"!isOverrideActive\"\n            :disabled=\"loading\"\n            :placeholder=\"loading ? '...' : ''\"\n            @input.stop=\"handleOverrideInput\"></FieldStreet>\n\n          <FieldCity\n            v-model=\"city\"\n            :readonly=\"!isOverrideActive\"\n            :disabled=\"loading\"\n            :placeholder=\"loading ? '...' : ''\"\n            @input.stop=\"handleOverrideInput\"></FieldCity>\n\n          <ButtonOverride\n            v-if=\"!loading && !isOverrideActive\"\n            @override-requested=\"isOverrideActive = true\"></ButtonOverride>\n        </template>\n      </template>\n\n      <template v-else>\n        <FieldAddressAutocomplete\n          v-model=\"searchQuery\"\n          @input.stop=\"handleAutocompleteInput\" />\n\n        <p v-if=\"searchQuery?.length && !isReadyForAutocompleteSearch\">\n          Enter at least a street and house number to start searching.<br />\n          Example:\n          <em> Herestraat 77 </em>\n        </p>\n\n        <template\n          v-if=\"addressResults && addressResults?.length > 1 && !loading\">\n          <FieldAddressSelect\n            :addresses=\"addressResults\"\n            @address-select=\"selectAddress\"></FieldAddressSelect>\n        </template>\n      </template>\n    </template>\n  </div>\n\n  <section>\n    <h2 class=\"font-bold\">Address to be sent to MyParcel:</h2>\n    <pre\n      v-if=\"selectedAddress\"\n      class=\"p-3 bg-slate-200 inline-block\"\n      >{{ selectedAddress }}</pre\n    >\n  </section>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref, toValue, watch, type Ref} from 'vue';\n\nimport {useDebounceFn} from '@vueuse/core';\n\nimport FieldAddressAutocomplete from '@/components/FieldAddressAutocomplete.vue';\nimport FieldAddressSelect from '@/components/FieldAddressSelect.vue';\nimport FieldCountry from '@/components/FieldCountry.vue';\nimport FieldPostalCode from '@/components/FieldPostalCode.vue';\nimport FieldHouseNumber from '@/components/FieldHouseNumber.vue';\nimport FieldHouseNumberSuffix from '@/components/FieldHouseNumberSuffix.vue';\nimport FieldStreet from '@/components/FieldStreet.vue';\nimport FieldCity from '@/components/FieldCity.vue';\nimport ButtonOverride from '@/components/ButtonOverride.vue';\n\nimport {useAddressApi} from '@/composables/useAdressApi';\nimport {\n  useAddressData,\n  type AddressSelectEvent,\n} from '@/composables/useAddressData';\n\nconst emit = defineEmits<AddressSelectEvent>();\n\n/** Address data **/\nconst {\n  countryCode,\n  searchQuery,\n  postalCode,\n  houseNumber,\n  houseNumberSuffix,\n  street,\n  city,\n  selectedAddress,\n  doReset,\n  selectAddress,\n  hasRequiredPostalcodeLookupAttributes,\n  isReadyForAutocompleteSearch,\n  isReadyForPostalCodeLookup,\n} = useAddressData(emit);\n\n/** UI states **/\nconst REQUEST_DEBOUNCE_TIME = 150;\n\ntype ValidationError = {\n  detail: string;\n  pointer: string;\n};\nconst validationErrors: Ref<ValidationError[] | undefined> = ref();\nconst notFound = ref(false);\nconst isOverrideActive = ref(false); // when the user wants to override the API response\n\n/** API states **/\nconst {\n  addressResults,\n  loading,\n  isProblemDetailsBadRequest,\n  fetchAddressByPostalCode,\n  fetchAddressBySearchQuery,\n} = useAddressApi();\n\n/**\n * Reset most of the state when the country changes.\n */\nconst handleCountryChange = () => {\n  doReset();\n  // Reset API results too\n  addressResults.value = undefined;\n};\n\n/**\n * Respond to input on postal code and house number fields with an API response when appropiate.\n * Currently, autocomplete on housenumber+postalCode is only available for NL.\n */\nconst handlePostalCodeInput = useDebounceFn(async () => {\n  const data = {\n    countryCode,\n    postalCode,\n    houseNumber,\n    houseNumberSuffix,\n  };\n  if (hasRequiredPostalcodeLookupAttributes(data)) {\n    try {\n      validationErrors.value = undefined;\n\n      // Pass values and not refs to make sure we use the current values\n      await fetchAddressByPostalCode(\n        toValue(data.postalCode),\n        toValue(data.houseNumber),\n        toValue(data.countryCode),\n        toValue(data.houseNumberSuffix),\n      );\n    } catch (error) {\n      if (isProblemDetailsBadRequest(error)) {\n        // @TODO handle validation error/integrate with form\n        validationErrors.value = error.errors;\n      } else {\n        // Re-throw any other error\n        throw error;\n      }\n    }\n  } else {\n    // Clear the results\n    addressResults.value = undefined;\n  }\n}, REQUEST_DEBOUNCE_TIME);\n\n/**\n * Respond to input of the autocomplete field with an API response when appropiate.\n * Currently this is only applied outside of NL.\n */\nconst handleAutocompleteInput = useDebounceFn(async () => {\n  if (isReadyForAutocompleteSearch.value) {\n    try {\n      validationErrors.value = undefined;\n\n      // Pass values and not refs to make sure we use the current values\n      await fetchAddressBySearchQuery(\n        toValue(searchQuery) as string,\n        toValue(countryCode),\n      );\n    } catch (error) {\n      if (isProblemDetailsBadRequest(error)) {\n        // @TODO handle validation error/integrate with form\n        validationErrors.value = error.errors;\n      }\n    }\n  } else {\n    // Clear the results\n    addressResults.value = undefined;\n  }\n}, REQUEST_DEBOUNCE_TIME);\n\n/**\n * When a user manually enters an address, override the selectedAddress with user-provided data and clear the API data.\n */\nconst handleOverrideInput = () => {\n  const postalData = {countryCode, postalCode, houseNumber};\n  if (\n    toValue(isOverrideActive) &&\n    hasRequiredPostalcodeLookupAttributes(postalData) &&\n    typeof street.value === 'string' &&\n    typeof city.value === 'string'\n  ) {\n    selectAddress({\n      street: street.value,\n      city: city.value,\n      postalCode: toValue(postalData.postalCode.value),\n      houseNumber: toValue(postalData.houseNumber.value),\n      houseNumberSuffix: toValue(houseNumberSuffix),\n      countryCode: toValue(postalData.countryCode),\n      postOfficeBox: false, // cannot be user-defined, so assume false,\n    });\n  }\n};\n\n/**\n * Handle UI updates when API results change.\n */\nwatch(addressResults, (results) => {\n  // Bail if there is not enough input to do an API call anyway\n  if (\n    !isReadyForAutocompleteSearch.value &&\n    !isReadyForPostalCodeLookup.value\n  ) {\n    return;\n  }\n  // Clear any selected address without clearing user input\n  selectedAddress.value = undefined;\n  street.value = undefined;\n  city.value = undefined;\n\n  /**\n   * If there's only one address, we may assume it's correct and select it.\n   * A user *must* make a selection when there are multiple results.\n   */\n  if (results?.length) {\n    notFound.value = false;\n  } else {\n    notFound.value = true;\n    console.warn('No address found, enter manually or try again');\n  }\n\n  // If there's only one address, select it\n  if (results?.length && toValue(results)?.length === 1) {\n    notFound.value = false;\n    selectAddress(toValue(results)[0]);\n  }\n});\n</script>\n","/**\n * This is the application file used to mount the full Vue app to the DOM. Mostly for demo purposes.\n */\nimport {createApp} from 'vue';\nimport App from './App.vue';\n\nconst app = createApp(App);\n\napp.mount('#form');\n"],"names":["noop","createFilterWrapper","filter","fn","wrapper","args","resolve","reject","debounceFilter","ms","options","timer","maxTimer","lastRejector","_clearTimeout","timer2","invoke","duration","toValue$1","maxDuration","useDebounceFn","model","_useModel","__props","_cache","_openBlock","_createElementBlock","searchQuery","props","computedOptions","computed","emit","__emit","addressOptions","address","index","onSelect","e","target","selectedIndex","selectedAddress","country","availableCountries","countryOptions","_a","postalCode","houseNumber","houseNumberSuffix","street","city","emitOverrideRequested","k","S","n","r","U","$","D","z","s","a","t","c","o","i","C","u","p","_","w","A","H","P","b","W","R","O","y","__publicField","T","E","Q","V","q","L","f","I","l","m","h","g","d","client","createClient","createConfig","getAddresses","API_URL_DIRECT","useConfig","apiKey","ref","apiUrl","setConfig","config","setConfigFromWindow","useApiClient","request","toValue","ABORT_REASON","useAddressApi","addressResults","loading","abortController","isProblemDetailsBadRequest","error","problemDetails","fetchAddressByPostalCode","countryCode","params","getAddressesWithErrorHandling","fetchAddressBySearchQuery","response","data","_b","SEARCH_STREET_MIN_LENGTH","POSTAL_CODE_MIN_LENGTH","useAddressData","doReset","selectAddress","hasRequiredPostalcodeLookupAttributes","isReadyForAutocompleteSearch","regex","isReadyForPostalCodeLookup","watch","REQUEST_DEBOUNCE_TIME","validationErrors","notFound","isOverrideActive","handleCountryChange","handlePostalCodeInput","handleAutocompleteInput","handleOverrideInput","postalData","results","app","createApp","App"],"mappings":"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","x_google_ignoreList":[0,13]}